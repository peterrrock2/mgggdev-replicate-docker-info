//! Data structures and algorithms for the recombination (ReCom) Markov chain.
use crate::buffers::SplitBuffer;
use crate::graph::Graph;
use crate::partition::Partition;
use rand::rngs::SmallRng;
use rand::Rng;

/// ReCom-based optimization.
pub mod opt;
/// ReCom batch size autotuning.
//mod autotune;
/// ReCom runners.
pub mod run;

/// A lightweight list-of-lists representation of a spanning tree.
type SpanningTree = Vec<Vec<usize>>;

/// A proposal generated by the ReCom chain.
///
/// We limit proposals to the merging and splitting of two districts.
/// (There is a generalized version of ReCom that merges and splits
/// an arbitrary number of districts at a time.) By convention, we
/// refer to the two districts in a merge/split operation as `a` and `b`.
#[derive(Clone)]
pub struct RecomProposal {
    /// The label of the `a`-district in the merge-split proposal.
    pub a_label: usize,
    /// The label of the `b`-district in the merge-split proposal.
    pub b_label: usize,
    /// The population of the proposed  `a`-district.
    pub a_pop: u32,
    /// The population of the proposed  `b`-district.
    pub b_pop: u32,
    /// The node indices in the proposed `a`-district.
    pub a_nodes: Vec<usize>,
    /// The node indices in the proposed `b`-district.
    pub b_nodes: Vec<usize>,
}

/// The supported variants of ReCom (unstable!)
#[derive(Copy, Clone, PartialEq)]
pub enum RecomVariant {
    /// Reversible ReCom.
    Reversible,
    /// Normal (non-reversible) ReCom with district pairs selected by
    /// choosing a random cut edge. Spanning trees are sampled from
    /// the uniform distribution.
    CutEdgesUST,
    /// Normal (non-reversible) ReCom with district pairs selected by
    /// choosing random pairs of district indices until an adjacent pair
    /// is found. Non-adjacent pairs are self-loops. Spanning trees are
    /// sampled from the uniform distribution.
    DistrictPairsUST,
    /// Normal (non-reversible) ReCom with district pairs selected by
    /// choosing a random cut edge. Spanning trees are sampled by drawing
    /// edge weights uniformly at random and finding the minimum spanning
    /// tree.
    CutEdgesRMST,
    /// Normal (non-reversible) ReCom with district pairs selected by
    /// choosing random pairs of district indices until an adjacent pair
    /// is found. Non-adjacent pairs are self-loops. Spanning trees are
    /// sampled by drawing edge weights uniformly at random and finding
    /// the minimum spanning tree.
    DistrictPairsRMST,
    /// Normal (non-reversible) ReCom with district pairs selected by
    /// choosing a random cut edge. Spanning trees are sampled by drawing
    /// edge weights at random and finding the minimum spanning tree;
    /// the weights on edges between regions (where regions might be counties,
    /// municipalities, or other geographies, potentially nested in a hierarchy)
    /// are sampled from different distributions than other edges such that
    /// districts are preferentially cut along region lines.
    CutEdgesRegionAware,
    /// Normal (non-reversible) ReCom with district pairs selected by
    /// choosing random pairs of district indices until an adjacent pair
    /// is found. Non-adjacent pairs are self-loops. Spanning trees are sampled by
    /// drawing edge weights at random and finding the minimum spanning tree;
    /// the weights on edges between regions (where regions might be counties,
    /// municipalities, or other geographies, potentially nested in a hierarchy)
    /// are sampled from different distributions than other edges such that
    /// districts are preferentially cut along region lines.
    DistrictPairsRegionAware,
}

/// The parameters of a ReCom chain run.
#[derive(Clone)]
pub struct RecomParams {
    /// The minimum population of a district.
    pub min_pop: u32,
    /// The maximum population of a district.
    pub max_pop: u32,
    /// A soft upper bound on the number of ε-balance nodes in a spanning tree.
    /// Only used for reversible ReCom.
    pub balance_ub: u32,
    /// The number of steps, including self-loops in the chain run.
    /// This does *not* necessarily correspond to the number of
    /// unique plans generated by the run.
    pub num_steps: u64,
    /// The seed of the random number of generator.
    pub rng_seed: u64,
    /// The type of ReCom chain to run.
    pub variant: RecomVariant,
    /// Weight parameters for region-aware ReCom, ordered by importance
    /// (highest to lowest).
    pub region_weights: Option<Vec<(String, f64)>>,
}

impl RecomProposal {
    /// Creates an empty ReCom proposal buffer with node lists of
    /// capacity `n`
    pub fn new_buffer(n: usize) -> RecomProposal {
        RecomProposal {
            a_label: 0,
            b_label: 0,
            a_pop: 0,
            b_pop: 0,
            a_nodes: Vec::<usize>::with_capacity(n),
            b_nodes: Vec::<usize>::with_capacity(n),
        }
    }

    /// Resets the proposal (useful when using as a reusable buffer).
    pub fn clear(&mut self) {
        self.a_nodes.clear();
        self.b_nodes.clear();
        // TODO: reset integer fields?
    }

    /// Returns the seam length of a proposal---that is,
    /// the number of cut edges along the boundary between the
    /// `a`-district and the `b`-district.
    ///
    /// Uses the underlying `graph`.
    pub fn seam_length(&self, graph: &Graph) -> usize {
        let mut a_mask = vec![false; graph.pops.len()];
        for &node in self.a_nodes.iter() {
            a_mask[node] = true;
        }
        let mut seam = 0;
        for &node in self.b_nodes.iter() {
            for &neighbor in graph.neighbors[node].iter() {
                if a_mask[neighbor] {
                    seam += 1;
                }
            }
        }
        return seam;
    }
}

/// Samples a pair of districts in `partition` uniformly at random using `rng`.
/// If the pair is not adjacent, returns `None`. Otherwise, returnsa
/// pair of district labels.
fn uniform_dist_pair(
    graph: &Graph,
    partition: &mut Partition,
    rng: &mut SmallRng,
) -> Option<(usize, usize)> {
    let dist_a = rng.gen_range(0..partition.num_dists) as usize;
    let dist_b = rng.gen_range(0..partition.num_dists) as usize;
    let num_dists = partition.num_dists;
    let dist_adj = partition.dist_adj(&graph);
    if dist_adj[(dist_a * num_dists as usize) + dist_b] == 0 {
        return None;
    }
    Some((dist_a, dist_b))
}

/// Samples a pair of districts in `partition` by choosing a cut edge
/// uniformly at random using `rng`.
fn cut_edge_dist_pair(
    graph: &Graph,
    partition: &mut Partition,
    rng: &mut SmallRng,
) -> (usize, usize) {
    let cut_edges = partition.cut_edges(&graph);
    if cut_edges.len() == 0 {
        panic!(
            "FATAL: No cut edges available. Something has gone terribly wrong. assignment: {:?}",
            partition.assignments
        );
    }
    let cut_edge_idx = rng.gen_range(0..cut_edges.len()) as usize;
    let edge_idx = cut_edges[cut_edge_idx] as usize;
    let dist_a = partition.assignments[graph.edges[edge_idx].0] as usize;
    let dist_b = partition.assignments[graph.edges[edge_idx].1] as usize;
    (dist_a, dist_b)
}

/// Attempts to propose a random recombination (spanning tree-based merge
/// and split) of districts `a` and `b` using a provided random MST. Returns
/// a `Result` containing either an error (to represent a self-loop) or
/// the number of balance nodes found when proposing (to represent a successful
/// proposal). The [RecomProposal] buffer (`buf`) is populated in place.
///
/// # Arguments
///
/// * `subgraph` - A graph containing the union of nodes in districts `a` and `b`.
/// * `rng` - The random number generator used to generate the proposal.
/// * `mst` - A minimum spanning tree of `subgraph`.
/// * `a` - The label of the `a`-district.
/// * `b` - The label of the `b`-district.
/// * `buf` - A buffer for use during split generation.
/// * `proposal` - The buffer to store the generated proposal in
///     (if the proposal is successful).
/// * `subgraph_map` - A map between the node IDs in the subgraph and the node IDs
///   of the parent graph. (Proposals use the node IDs in the parent graph.)
/// * `params` - The parameters of the parent ReCom chain.
pub fn random_split(
    subgraph: &Graph,
    rng: &mut SmallRng,
    mst: &SpanningTree,
    a: usize,
    b: usize,
    buf: &mut SplitBuffer,
    proposal: &mut RecomProposal,
    subgraph_map: &Vec<usize>,
    params: &RecomParams,
) -> Result<usize, String> {
    // Find ε-balanced cuts (if any), then choose a cut at random if possible.
    match (params.variant, balanced_cuts(subgraph, mst, buf, params)) {
        (_, Err(e)) => Err(e),
        (RecomVariant::CutEdgesRegionAware, Ok(_))
        | (RecomVariant::DistrictPairsRegionAware, Ok(_)) => Ok(choose_region_aware_random_cut(
            subgraph,
            rng,
            buf,
            proposal,
            subgraph_map,
            a,
            b,
            params.region_weights.as_ref().unwrap(),
        )),
        (_, Ok(_)) => Ok(choose_random_cut(
            subgraph,
            rng,
            buf,
            proposal,
            subgraph_map,
            a,
            b,
        )),
    }
}

/// Finds ε-balanced cuts (if any) in a spanning tree.
fn balanced_cuts(
    subgraph: &Graph,
    mst: &SpanningTree,
    buf: &mut SplitBuffer,
    params: &RecomParams,
) -> Result<(), String> {
    buf.clear();
    let n = subgraph.pops.len();
    let mut root = 0;
    while root < n {
        if subgraph.neighbors[root].len() > 1 {
            break;
        }
        root += 1;
    }
    if root == n {
        return Err("no leaf nodes in MST".to_string());
    }
    // Traverse the MST.
    buf.deque.push_back(root);
    while let Some(next) = buf.deque.pop_front() {
        buf.visited[next] = true;
        for &neighbor in mst[next].iter() {
            if !buf.visited[neighbor] {
                buf.deque.push_back(neighbor);
                buf.succ[next].push(neighbor);
                buf.pred[neighbor] = next;
            }
        }
    }

    // Recursively compute populations of subtrees.
    buf.deque.push_back(root);
    while let Some(next) = buf.deque.pop_back() {
        if !buf.pop_found[next] {
            if subgraph.neighbors[next].len() == 1 {
                buf.tree_pops[next] = subgraph.pops[next];
                buf.pop_found[next] = true;
            } else {
                // Populations of all child nodes found. :)
                if buf.succ[next].iter().all(|&node| buf.pop_found[node]) {
                    buf.tree_pops[next] =
                        buf.succ[next].iter().map(|&node| buf.tree_pops[node]).sum();
                    buf.tree_pops[next] += subgraph.pops[next];
                    buf.pop_found[next] = true;
                } else {
                    // Come back later.
                    buf.deque.push_back(next);
                    for &neighbor in buf.succ[next].iter() {
                        if !buf.pop_found[neighbor] {
                            buf.deque.push_back(neighbor);
                        }
                    }
                }
            }
        }
    }

    // Find ε-balanced cuts.
    for (index, &pop) in buf.tree_pops.iter().enumerate() {
        if pop >= params.min_pop
            && pop <= params.max_pop
            && subgraph.total_pop - pop >= params.min_pop
            && subgraph.total_pop - pop <= params.max_pop
        {
            buf.balance_nodes.push(index);
        }
    }
    if buf.balance_nodes.is_empty() {
        return Err("no balanced cuts".to_string());
    }
    Ok(())
}

/// Given a buffer of random splits and a specified balance node within the
/// buffer, generates the ReCom proposal induced by cutting at the balance node.
fn generate_cut_from_balance_node(
    subgraph: &Graph,
    buf: &mut SplitBuffer,
    balance_node_index: usize,
    proposal: &mut RecomProposal,
    subgraph_map: &Vec<usize>,
    a: usize,
    b: usize,
) -> usize {
    proposal.clear();

    let balance_node = buf.balance_nodes[balance_node_index];
    buf.deque.push_back(balance_node);

    // Extract the nodes for the random cut.
    let mut a_pop = 0;
    while let Some(next) = buf.deque.pop_front() {
        if !buf.in_a[next] {
            proposal.a_nodes.push(subgraph_map[next]);
            a_pop += subgraph.pops[next];
            buf.in_a[next] = true;
            for &node in buf.succ[next].iter() {
                buf.deque.push_back(node);
            }
        }
    }
    for index in 0..subgraph.pops.len() {
        if !buf.in_a[index] {
            proposal.b_nodes.push(subgraph_map[index]);
        }
    }
    proposal.a_label = a;
    proposal.b_label = b;
    proposal.a_pop = a_pop;
    proposal.b_pop = subgraph.total_pop - a_pop;
    buf.balance_nodes.len()
}

/// Chooses a random cut from a nonempty set of available ε-balanced cuts
/// and generates the ReCom proposal induced by the cut.
fn choose_random_cut(
    subgraph: &Graph,
    rng: &mut SmallRng,
    buf: &mut SplitBuffer,
    proposal: &mut RecomProposal,
    subgraph_map: &Vec<usize>,
    a: usize,
    b: usize,
) -> usize {
    let balance_node_index = rng.gen_range(0..buf.balance_nodes.len());
    generate_cut_from_balance_node(
        subgraph,
        buf,
        balance_node_index,
        proposal,
        subgraph_map,
        a,
        b,
    )
}

fn choose_region_aware_random_cut(
    subgraph: &Graph,
    rng: &mut SmallRng,
    buf: &mut SplitBuffer,
    proposal: &mut RecomProposal,
    subgraph_map: &Vec<usize>,
    a: usize,
    b: usize,
    region_weights: &[(String, f64)],
) -> usize {
    let mut balance_nodes_by_weight = vec![];
    for (idx, &lhs) in buf.balance_nodes.iter().enumerate() {
        let rhs = buf.pred[lhs];
        // We favor balance edges that cleanly separate regions.
        let mut edge_weight = 0.0;
        for (attr, attr_weight) in region_weights.iter() {
            if subgraph.attr[attr][lhs] != subgraph.attr[attr][rhs] {
                edge_weight += *attr_weight;
            }
        }
        balance_nodes_by_weight.push((edge_weight, idx));
    }

    // Choose a random balance node among the set of nodes with highest weight.
    let max_weight = balance_nodes_by_weight
        .iter()
        .max_by(|(a, _), (b, _)| a.partial_cmp(b).unwrap())
        .map(|(k, _)| k)
        .unwrap()
        .clone();
    let candidates: Vec<usize> = balance_nodes_by_weight
        .into_iter()
        .filter(|(weight, _)| (weight - max_weight).abs() < 1e-16)
        .map(|(_, idx)| idx)
        .collect();
    let balance_node_index = candidates[rng.gen_range(0..candidates.len())];
    generate_cut_from_balance_node(
        subgraph,
        buf,
        balance_node_index,
        proposal,
        subgraph_map,
        a,
        b,
    )
}

/// Returns the maximum number of nodes in two districts based on node
/// populations (`pop`) and the maximum district population (`max_pop`).
///
/// Used to choose buffer sizes for recombination steps.
fn node_bound(pops: &Vec<u32>, max_pop: u32) -> usize {
    let mut sorted_pops = pops.clone();
    sorted_pops.sort();
    let mut node_bound = 0;
    let mut total = 0;
    while total < 2 * max_pop && node_bound < pops.len() {
        total += sorted_pops[node_bound];
        node_bound += 1;
    }
    return node_bound + 1;
}
